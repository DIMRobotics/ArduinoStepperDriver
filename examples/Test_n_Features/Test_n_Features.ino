#include <StepperDriver.h>

/* Идентификаторы осей внутри библиотеки; по ним потом
 * можно управлять конкретной. Осей можно делать несколько,
 * максимальное число в родной сборке - 3. Лечится правкой
 * хедерфайла, там есть константа NUM_AXSIS
 */ 
axis_t left, right;

void setup()
{
  /* Инициализация драйвера: таймеры */
  StepperDriver.init();
  
  /* Регистрация управляемых осей. Здесь по порядку
   * идут три номера пинов: STEP, DIR, ENABLE.
   * Если ENABLE не нужен или не существует, вписать 255,
   * это значение-заглушка. Четвёртое значение - число шагов за оборот
   * у движка.
   */
  left = StepperDriver.newAxis(1, 2, 3, 500);
  right = StepperDriver.newAxis(4, 5, 6, 500);
  
  /* Включаем оси (если необходимо).
   * Выключаются по образу и подобию:
   * StepperDriver.disable(axis);
   */
  StepperDriver.enable(left);
  StepperDriver.enable(right);
  
  /* Инициализация шасси: сюда передать по
   * порядку идентификаторы левой и правой оси.
   * Этот объект использовать не обязательно, он помогает
   * только в том случае, если на ШД сделан непосредственно
   * привод робота. Через StepperDriver можно делать все
   * основные операции с движками.
   *
   * В перспективе думаю убрать этот объект, сделав более
   * универсальный класс Chassis для комфортного управления
   * шасси робота вне зависимости от типа движков.
   */
  StepperChassis.init(left, right);
}

void loop()
{
  /* Для управления осями есть набор родных функций драйвера:
   * Низкоуровневые:
   *  setDir(axis, dir) - dir может быть FORWARD и BACKWARD
   *  setDelay(axis, delay) - задать длину шага (в условных тиках)
   *  setSpeed(axis, speed) - задать скорость.
   *   Скорость задаётся в оборотах в минуту!
   *   Скорость, как и задержка, варьируется от 0 до 65535.
   *
   * Как только задана скорость или задержка, движок начинает
   * крутиться с заданным параметром, причём в фоновом режиме.
   */
  StepperDriver.setDir(left, FORWARD);
  StepperDriver.setSpeed(left, 10000);
  delay(1000);
  StepperDriver.setDir(left, BACKWARD);
  StepperDriver.setSpeed(left, 40000);
  delay(1000);
  
  /* Ещё есть несколько высокоуровневых функций.
   * stop(axis) - остановка движка */
  StepperDriver.stop(left);
  delay(1000);
 
  /* write(axis, value) - берёт значение со знаком
   * и превращает его в направление и скорость */
  StepperDriver.write(left, 30000);
  delay(1000);
  StepperDriver.write(left, -30000);
  delay(1000);
  
  /* Ещё одно применение функции write:
   * write(axis, value, path)
   * Крутит движком, пока не пройдёт заданный путь.
   * Путь сюда подавать ПОЛОЖИТЕЛЬНЫЙ, направление задавать
   * знаком скорости.
   *
   * Так как движок всё равно крутится в фоновом режиме, есть
   * две функции для определения конца движения:
   * busy(axis) - возвращает 1, если движок ещё в пути и 0 иначе
   * wait(axis) - тупо ждёт окончания движения
   *
   * Функция move(axis, speed, path) работает так же, как
   * write и wait после него. (То есть выход из функции случится
   * только в конце пути)
   */
  StepperDriver.stop(left);
  delay(1000);
   
  StepperDriver.write(left, 30000, 300);
  StepperDriver.wait(left);
   
  StepperDriver.write(left, -30000, 300);
  while (StepperDriver.busy(left)) {
    /* делаем что-то полезное */
  }
   
  StepperDriver.move(left, 10000, 300);
   
  /* Наконец, пройденный путь можно считывать функцией
   * getPath(axis) (вернёт int32_t)
   * 
   * Сбросить накопленное значение можно функцией
   * resetPath(axis)
   */
  int32_t path = StepperDriver.getPath(left);
  Serial.println(path);
  StepperDriver.resetPath(left);
  
  delay(1000);
}

